#!/usr/bin/perl -w
use strict;
use FileHandle;
## Monitor output/*.out and *.err and report on state of system

## Open every file in the output diretctory and monitor the output.

## Encode here knowledge about what 120Proof programmes ouitput.  This is tightly linked.


$|++; #Flush
use lib("$ENV{'Home120Proof'}/Perl");
use One20Proof;


my $output_dir = "$ENV{'Home120Proof'}/output/";
opendir(my $dir, $output_dir) or die "$! $output_dir";

# Get all the input files
my @files = grep {$_ =~ /[a-z]/} grep{$_ !~ /~/} readdir($dir) or die $!;

my %fh = ();
my $bits = '';
foreach my $fn (@files){
    # my $fh = FileHandle->new(
    open(my $fh, "$output_dir/$fn") or die "$!: $fn ";
    vec($bits, fileno($fh),  1) = 1;

    ## Associate a file name and file handle
    $fh{$fn} = $fh;
}


## The state of 120Proof.  
my %state  = ();

## $length is the amount of data to read at a tmime from file handle
## If missing data from file $bytes_read will be == $length.
## So increase $length
my $length = 1;
# my $length = 4096;
while(1){
    my ($a, $b) = select(my $bytes = $bits, undef, undef, undef);
    if($a == -1){
	warn "$! Fail";
    }else{
	## Got some data
	my $buffer;

	foreach my $fn (sort keys %fh){
	    ## Check each file
	    my $bytes_read = sysread($fh{$fn}, $buffer, $length);
	    if($bytes_read == $length){
		warn "Length => $length -> ".($length*2)." ";
		$length *= 2;
	    }
	    if($bytes_read > 0){
		## Got some data.
		my @lines = split(/\n/, $buffer);
		if($fn eq "lpx_controll.out"){

		    my @running =
			map{/subs\/ON-(\S+)/ and $1}
			grep {/Run command: $ENV{Home120Proof}\/subs\/\S+$/} @lines;
		    # warn " Run command:$ENV{Home120Proof}\/subs\/(\S+) ";
		    # warn "'$lines[0]'";
		    if(@running){
			if(scalar(@running) > 1){
			    warn "\@running too long: ".join(", ", @running);
			}
			$state{running} = $running[$#running];
		    }
		}
		# print("$fn: Looped: \$bytes_read: $bytes_read \n");

		## Check for xruns
		if(grep {/xrun reported/} @lines){
		    $state{xrun} = time();
		}
	    }

	}
    }

    ## Output state (This is where ncurese can be useful)
    my $running = defined($state{running}) ? $state{running} : "    "; 
    my $xrun_time = "";
    if(defined $state{xrun}){
	my $last_xrun = $state{xrun};
	$xrun_time = time() - $last_xrun;
	$xrun_time .= " seconds since last xrun";
    }
    print "\r$running\t $xrun_time           ";
}
