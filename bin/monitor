#!/usr/bin/perl -w
use strict;
use FileHandle;

## Monitor output/*.out and *.err and report on state of system

## Open every file in the output diretctory and monitor the output.

## Encode here knowledge about what 120Proof programmes ouitput.  This is tightly linked.

$|++; #Flush
use lib("$ENV{'Home120Proof'}/Perl");
use One20Proof;
#use OutputFilesState;

my $output_dir = "$ENV{'Home120Proof'}/output/";
my $o = OutputFilesState->new($output_dir);
$o->initialise();
while(1){
    $o->update();

    print $o->output();
    sleep(.1);
}

exit;




opendir(my $dir, $output_dir) or die "$! $output_dir";

# Get all the input files
my @files = grep {$_ =~ /[a-z]/} grep{$_ !~ /~/} readdir($dir) or die "$!: Failed to read from $output_dir";

my %fh = ();
my $bits = '';
foreach my $fn (@files){
    # my $fh = FileHandle->new(
    open(my $fh, "$output_dir/$fn") or die "$!: $fn ";
    vec($bits, fileno($fh),  1) = 1;

    ## Associate a file name and file handle
    $fh{$fn} = $fh;
}


## The state of 120Proof.  
my %state  = ();

## $length is the amount of data to read at a time from file handle
## If missing data from file $bytes_read will be == $length.
## So increase $length
##my $length = 1;
my $length = 4096;
while(1){
    my ($a, $b) = select(my $bytes = $bits, undef, undef, 0.1);
    if($a == -1){
	warn "$! Fail";
    }else{
	## Got some data
	my $buffer;

	foreach my $fn (sort keys %fh){
	    ## Check each file
	    my $bytes_read = sysread($fh{$fn}, $buffer, $length);
	    if($bytes_read == $length){
		warn "Length => $length -> ".($length*2)." ";
		$length *= 2;
	    }
	    if($bytes_read > 0){
		## Got some data.
		my @lines = split(/\n/, $buffer);

		if($fn =~ /^(.+).err$/){
		    # All the errors
		    print scalar(localtime())." e\n";
		    print join("", map{"$1 e $_\n"} @lines);
		    print "eeeeeeeeeeee\n";
		}elsif($fn =~ /^(.+).out$/){
		    # All the stdout
		    print scalar(localtime())." o\n";
		    print join("", map{"$1 o $_\n"} @lines);
		    print "oooooooooooo\n";
		}else{
		    print "-- $fn\n";
		}
		# print("$fn: Looped: \$bytes_read: $bytes_read \n");

		## Check for xruns
		if(grep {/xrun reported/} @lines){
		    $state{xrun} = time();
		}
	    }

	}
    }
    sleep(0.1);
}

## To facilitate monitoring the strate of files in the output directory
## man perlobj
package OutputFilesState;
sub new {
    my $class = shift;

    ## The directory to monitor
    my $path = shift or die;
    -d $path or die "Pass the path to a directory";
    $path =~ /\/$/ or $path .= '/';
    my $self = {path => $path};
    
    return bless $self, $class;
}

sub initialise() {
    my $self = shift;

    ## Get a handle to the output directory
    opendir(my $dh, $self->{path}) or die "$!";
    $self->{dir} = $dh;

    ## Initialise cache
    $self->{cache} = {};

    
}

sub list() {
    my $self = shift;
    rewinddir($self->{dir});
    my @files = map{$self->{path}.$_}
    grep{/[^\.]/} ## Some non dod character
    grep {$_ !~ /\#/} ## Emacs writes these files temporarily
    readdir($self->{dir});
    return @files;
}

sub update() {
    my $self = shift;

    foreach my $fn ($self->list()){
	
	my $new_data = "";
	$self->{cache}->{$fn} or $self->{cache}->{$fn} = [0, ""];

	open(my $fh, $fn) or die "$!: $fn";
	my @stat = stat($fh) or die "$!: $fn";
	my $sz = $stat[7]; ## Actual size
	my $csz = $self->{cache}->{$fn}->[0]; ## Cached size
	$self->{cache}->{$fn}->[0] = $sz;
	
	if($sz > $csz){
	    ## File size has grown.  Read the latest data
	    seek($fh, $csz, 0);

	    while(my $ln = <$fh>){
		$new_data .= $ln;
	    }
	}elsif($sz < $csz){
	    ## File has been restarted.  Read it all
	    seek($fh, 0, 0);

	    while(my $ln = <$fh>){
		$new_data .= $ln;
	    }
	}
	$self->{cache}->{$fn}->[1] = $new_data;
    }
}

sub output {
    my $self = shift;
    my $result = "";
    foreach my $fn (keys(%{$self->{cache}})){
	$fn =~ /([^\/]+)$/ or die "\$fn makes no sense: '$fn'";
	my $name = $1;
	my @output = split("\n", $self->{cache}->{$fn}->[1]);
	for my $l (@output){	    
	    $result .=  "$name: $l\n";
	}
    }
    return $result;
}
1;
